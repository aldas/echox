<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Middlewares on Echo - High performance, minimalist Go web framework</title>
    <link>https://echo.labstack.com/middleware/</link>
    <description>Recent content in Middlewares on Echo - High performance, minimalist Go web framework</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language><atom:link href="https://echo.labstack.com/middleware/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Basic Auth Middleware</title>
      <link>https://echo.labstack.com/middleware/basic-auth/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://echo.labstack.com/middleware/basic-auth/</guid>
      <description>Basic auth middleware provides an HTTP basic authentication.
 For valid credentials it calls the next handler. For missing or invalid credentials, it sends &amp;ldquo;401 - Unauthorized&amp;rdquo; response.  Usage
e.Use(middleware.BasicAuth(func(username, password string, c echo.Context) (bool, error) { // Be careful to use constant time comparison to prevent timing attacks 	if subtle.ConstantTimeCompare([]byte(username), []byte(&amp;#34;joe&amp;#34;)) == 1 &amp;amp;&amp;amp; subtle.ConstantTimeCompare([]byte(password), []byte(&amp;#34;secret&amp;#34;)) == 1 { return true, nil } return false, nil })) Custom Configuration Usage</description>
    </item>
    
    <item>
      <title>Body Dump Middleware</title>
      <link>https://echo.labstack.com/middleware/body-dump/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://echo.labstack.com/middleware/body-dump/</guid>
      <description>Body dump middleware captures the request and response payload and calls the registered handler. Generally used for debugging/logging purpose. Avoid using it if your request/response payload is huge e.g. file upload/download, but if you still need to, add an exception for your endpoints in the skipper function.
Usage
e := echo.New() e.Use(middleware.BodyDump(func(c echo.Context, reqBody, resBody []byte) { })) Custom Configuration Usage
e := echo.New() e.Use(middleware.BodyDumpWithConfig(middleware.BodyDumpConfig{})) Configuration BodyDumpConfig struct { // Skipper defines a function to skip middleware.</description>
    </item>
    
    <item>
      <title>Body Limit Middleware</title>
      <link>https://echo.labstack.com/middleware/body-limit/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://echo.labstack.com/middleware/body-limit/</guid>
      <description>Body limit middleware sets the maximum allowed size for a request body, if the size exceeds the configured limit, it sends &amp;ldquo;413 - Request Entity Too Large&amp;rdquo; response. The body limit is determined based on both Content-Length request header and actual content read, which makes it super secure.
Limit can be specified as 4x or 4xB, where x is one of the multiple from K, M, G, T or P.</description>
    </item>
    
    <item>
      <title>Casbin Auth Middleware</title>
      <link>https://echo.labstack.com/middleware/casbin-auth/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://echo.labstack.com/middleware/casbin-auth/</guid>
      <description>Casbin is a powerful and efficient open-source access control library for Go. It provides support for enforcing authorization based on various models. So far, the access control models supported by Casbin are:
 ACL (Access Control List) ACL with superuser ACL without users: especially useful for systems that don&amp;rsquo;t have authentication or user log-ins. ACL without resources: some scenarios may target for a type of resources instead of an individual resource by using permissions like write-article, read-log.</description>
    </item>
    
    <item>
      <title>CORS Middleware</title>
      <link>https://echo.labstack.com/middleware/cors/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://echo.labstack.com/middleware/cors/</guid>
      <description>CORS middleware implements CORS specification. CORS gives web servers cross-domain access controls, which enable secure cross-domain data transfers.
Usage
e.Use(middleware.CORS())
Custom Configuration Usage
e := echo.New() e.Use(middleware.CORSWithConfig(middleware.CORSConfig{ AllowOrigins: []string{&amp;#34;https://labstack.com&amp;#34;, &amp;#34;https://labstack.net&amp;#34;}, AllowHeaders: []string{echo.HeaderOrigin, echo.HeaderContentType, echo.HeaderAccept}, })) Configuration CORSConfig struct { // Skipper defines a function to skip middleware.  Skipper Skipper // AllowOrigin defines a list of origins that may access the resource.  // Optional. Default value []string{&amp;#34;*&amp;#34;}.  AllowOrigins []string `yaml:&amp;#34;allow_origins&amp;#34;` // AllowOriginFunc is a custom function to validate the origin.</description>
    </item>
    
    <item>
      <title>CSRF Middleware</title>
      <link>https://echo.labstack.com/middleware/csrf/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://echo.labstack.com/middleware/csrf/</guid>
      <description>Cross-site request forgery, also known as one-click attack or session riding and abbreviated as CSRF (sometimes pronounced sea-surf) or XSRF, is a type of malicious exploit of a website where unauthorized commands are transmitted from a user that the website trusts.
Usage
e.Use(middleware.CSRF())
Custom Configuration Usage
e := echo.New() e.Use(middleware.CSRFWithConfig(middleware.CSRFConfig{ TokenLookup: &amp;#34;header:X-XSRF-TOKEN&amp;#34;, })) Example above uses X-XSRF-TOKEN request header to extract CSRF token.
Accessing CSRF Token Server-side CSRF token can be accessed from Echo#Context using ContextKey and passed to the client via template.</description>
    </item>
    
    <item>
      <title>Decompress Middleware</title>
      <link>https://echo.labstack.com/middleware/decompress/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://echo.labstack.com/middleware/decompress/</guid>
      <description>Decompress middleware decompresses HTTP request if Content-Encoding header is set to gzip. *Please note: The body will be decompressed in memory and consume it for the lifetime of the request (and garbage collection).
Usage
e.Use(middleware.Decompress())
Custom Configuration Usage
e := echo.New() e.Use(middleware.DecompressWithConfig(middleware.DecompressConfig{ Skipper: Skipper })) Configuration DecompressConfig struct { // Skipper defines a function to skip middleware.  Skipper Skipper } Default Configuration
DefaultDecompressConfig = DecompressConfig{ Skipper: DefaultSkipper, } </description>
    </item>
    
    <item>
      <title>Gzip Middleware</title>
      <link>https://echo.labstack.com/middleware/gzip/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://echo.labstack.com/middleware/gzip/</guid>
      <description>Gzip middleware compresses HTTP response using gzip compression scheme.
Usage
e.Use(middleware.Gzip())
Custom Configuration Usage
e := echo.New() e.Use(middleware.GzipWithConfig(middleware.GzipConfig{ Level: 5, })) Configuration GzipConfig struct { // Skipper defines a function to skip middleware.  Skipper Skipper // Gzip compression level.  // Optional. Default value -1.  Level int `json:&amp;#34;level&amp;#34;` } Default Configuration
DefaultGzipConfig = GzipConfig{ Skipper: DefaultSkipper, Level: -1, } Middleware Skipper A middleware skipper can be passed to avoid gzip to certain URLs:</description>
    </item>
    
    <item>
      <title>Jaeger Tracing Middleware</title>
      <link>https://echo.labstack.com/middleware/jaegertracing/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://echo.labstack.com/middleware/jaegertracing/</guid>
      <description>Trace requests on Echo framework with Jaeger Tracing Middleware.
Usage
package main import ( &amp;#34;github.com/labstack/echo-contrib/jaegertracing&amp;#34; &amp;#34;github.com/labstack/echo/v4&amp;#34; ) func main() { e := echo.New() // Enable tracing middleware  c := jaegertracing.New(e, nil) defer c.Close() e.Logger.Fatal(e.Start(&amp;#34;:1323&amp;#34;)) } Enabling the tracing middleware creates a tracer and a root tracing span for every request.
Custom Configuration By default, traces are sent to localhost Jaeger agent instance. To configure an external Jaeger, start your application with environment variables.</description>
    </item>
    
    <item>
      <title>JWT Middleware</title>
      <link>https://echo.labstack.com/middleware/jwt/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://echo.labstack.com/middleware/jwt/</guid>
      <description>JWT provides a JSON Web Token (JWT) authentication middleware.
 For valid token, it sets the user in context and calls next handler. For invalid token, it sends &amp;ldquo;401 - Unauthorized&amp;rdquo; response. For missing or invalid Authorization header, it sends &amp;ldquo;400 - Bad Request&amp;rdquo;.  Usage
e.Use(middleware.JWT([]byte(&amp;quot;secret&amp;quot;)))
Custom Configuration Usage
e.Use(middleware.JWTWithConfig(middleware.JWTConfig{ SigningKey: []byte(&amp;#34;secret&amp;#34;), TokenLookup: &amp;#34;query:token&amp;#34;, })) Usage with different JWT library/repository
 Note: To be backwards compatible Echo still uses the currently unmaintained JWT implementation dgrijalva/jwt-go, which has known potential security risks.</description>
    </item>
    
    <item>
      <title>Key Auth Middleware</title>
      <link>https://echo.labstack.com/middleware/key-auth/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://echo.labstack.com/middleware/key-auth/</guid>
      <description>Key auth middleware provides a key based authentication.
 For valid key it calls the next handler. For invalid key, it sends &amp;ldquo;401 - Unauthorized&amp;rdquo; response. For missing key, it sends &amp;ldquo;400 - Bad Request&amp;rdquo; response.  Usage
e.Use(middleware.KeyAuth(func(key string, c echo.Context) (bool, error) { return key == &amp;#34;valid-key&amp;#34;, nil })) Custom Configuration Usage
e := echo.New() e.Use(middleware.KeyAuthWithConfig(middleware.KeyAuthConfig{ KeyLookup: &amp;#34;query:api-key&amp;#34;, Validator: func(key string, c echo.Context) (bool, error) { return key == &amp;#34;valid-key&amp;#34;, nil }, })) Configuration KeyAuthConfig struct { // Skipper defines a function to skip middleware.</description>
    </item>
    
    <item>
      <title>Logger Middleware</title>
      <link>https://echo.labstack.com/middleware/logger/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://echo.labstack.com/middleware/logger/</guid>
      <description>Logger middleware logs the information about each HTTP request.
Usage
e.Use(middleware.Logger())
Sample Output
{&amp;#34;time&amp;#34;:&amp;#34;2017-01-12T08:58:07.372015644-08:00&amp;#34;,&amp;#34;remote_ip&amp;#34;:&amp;#34;::1&amp;#34;,&amp;#34;host&amp;#34;:&amp;#34;localhost:1323&amp;#34;,&amp;#34;method&amp;#34;:&amp;#34;GET&amp;#34;,&amp;#34;uri&amp;#34;:&amp;#34;/&amp;#34;,&amp;#34;status&amp;#34;:200,&amp;#34;error&amp;#34;:&amp;#34;&amp;#34;,&amp;#34;latency&amp;#34;:14743,&amp;#34;latency_human&amp;#34;:&amp;#34;14.743µs&amp;#34;,&amp;#34;bytes_in&amp;#34;:0,&amp;#34;bytes_out&amp;#34;:2} Custom Configuration Usage
e.Use(middleware.LoggerWithConfig(middleware.LoggerConfig{ Format: &amp;#34;method=${method}, uri=${uri}, status=${status}\n&amp;#34;, })) Example above uses a Format which logs request method and request URI.
Sample Output
method=GET, uri=/, status=200 Configuration // LoggerConfig defines the config for Logger middleware. LoggerConfig struct { // Skipper defines a function to skip middleware.  Skipper Skipper // Tags to construct the logger format.  //  // - time_unix  // - time_unix_nano  // - time_rfc3339  // - time_rfc3339_nano  // - time_custom  // - id (Request ID)  // - remote_ip  // - uri  // - host  // - method  // - path  // - protocol  // - referer  // - user_agent  // - status  // - error  // - latency (In nanoseconds)  // - latency_human (Human readable)  // - bytes_in (Bytes received)  // - bytes_out (Bytes sent)  // - header:&amp;lt;NAME&amp;gt;  // - query:&amp;lt;NAME&amp;gt;  // - form:&amp;lt;NAME&amp;gt;  //  // Example &amp;#34;${remote_ip} ${status}&amp;#34;  //  // Optional.</description>
    </item>
    
    <item>
      <title>Method Override Middleware</title>
      <link>https://echo.labstack.com/middleware/method-override/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://echo.labstack.com/middleware/method-override/</guid>
      <description>Method override middleware checks for the overridden method from the request and uses it instead of the original method.
For security reasons, only POST method can be overridden.
Usage
e.Pre(middleware.MethodOverride())
Custom Configuration Usage
e := echo.New() e.Pre(middleware.MethodOverrideWithConfig(middleware.MethodOverrideConfig{ Getter: middleware.MethodFromForm(&amp;#34;_method&amp;#34;), })) Configuration MethodOverrideConfig struct { // Skipper defines a function to skip middleware.  Skipper Skipper // Getter is a function that gets overridden method from the request.  // Optional. Default values MethodFromHeader(echo.</description>
    </item>
    
    <item>
      <title>Prometheus Middleware</title>
      <link>https://echo.labstack.com/middleware/prometheus/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://echo.labstack.com/middleware/prometheus/</guid>
      <description>Prometheus middleware generates metrics for HTTP requests.
Usage
package main import ( &amp;#34;github.com/labstack/echo/v4&amp;#34; &amp;#34;github.com/labstack/echo-contrib/prometheus&amp;#34; ) func main() { e := echo.New() // Enable metrics middleware  p := prometheus.NewPrometheus(&amp;#34;echo&amp;#34;, nil) p.Use(e) e.Logger.Fatal(e.Start(&amp;#34;:1323&amp;#34;)) } Sample Output
curl http://localhost:1323/metrics # HELP echo_request_duration_seconds The HTTP request latencies in seconds. # TYPE echo_request_duration_seconds summary echo_request_duration_seconds_sum 0.41086482 echo_request_duration_seconds_count 1 # HELP echo_request_size_bytes The HTTP request sizes in bytes. # TYPE echo_request_size_bytes summary echo_request_size_bytes_sum 56 echo_request_size_bytes_count 1 # HELP echo_requests_total How many HTTP requests processed, partitioned by status code and HTTP method.</description>
    </item>
    
    <item>
      <title>Proxy Middleware</title>
      <link>https://echo.labstack.com/middleware/proxy/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://echo.labstack.com/middleware/proxy/</guid>
      <description>Proxy provides an HTTP/WebSocket reverse proxy middleware. It forwards a request to upstream server using a configured load balancing technique.
Usage url1, err := url.Parse(&amp;#34;http://localhost:8081&amp;#34;) if err != nil { e.Logger.Fatal(err) } url2, err := url.Parse(&amp;#34;http://localhost:8082&amp;#34;) if err != nil { e.Logger.Fatal(err) } e.Use(middleware.Proxy(middleware.NewRoundRobinBalancer([]*middleware.ProxyTarget{ { URL: url1, }, { URL: url2, }, }))) Custom Configuration Usage e := echo.New() e.Use(middleware.ProxyWithConfig(middleware.ProxyConfig{})) Configuration // ProxyConfig defines the config for Proxy middleware.  ProxyConfig struct { // Skipper defines a function to skip middleware.</description>
    </item>
    
    <item>
      <title>Rate Limiter Middleware</title>
      <link>https://echo.labstack.com/middleware/rate-limiter/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://echo.labstack.com/middleware/rate-limiter/</guid>
      <description>RateLimiter provides a Rate Limiter middleware for limiting the amount of requests to the server from a particular IP or id within a time period.
By default an in-memory store is used for keeping track of requests. The default in-memory implementation is focused on correctness and may not be the best option for a high number of concurrent requests or a large number of different identifiers (&amp;gt;16k).
Usage To add a rate limit to your application simply add the RateLimiter middlware.</description>
    </item>
    
    <item>
      <title>Recover Middleware</title>
      <link>https://echo.labstack.com/middleware/recover/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://echo.labstack.com/middleware/recover/</guid>
      <description>Recover middleware recovers from panics anywhere in the chain, prints stack trace and handles the control to the centralized HTTPErrorHandler.
Usage
e.Use(middleware.Recover())
Custom Configuration Usage
e := echo.New() e.Use(middleware.RecoverWithConfig(middleware.RecoverConfig{ StackSize: 1 &amp;lt;&amp;lt; 10, // 1 KB  LogLevel: log.ERROR, })) Example above uses a StackSize of 1 KB, LogLevel of error and default values for DisableStackAll and DisablePrintStack.
Configuration RecoverConfig struct { // Skipper defines a function to skip middleware.  Skipper Skipper // Size of the stack to be printed.</description>
    </item>
    
    <item>
      <title>Redirect Middleware</title>
      <link>https://echo.labstack.com/middleware/redirect/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://echo.labstack.com/middleware/redirect/</guid>
      <description>HTTPS Redirect HTTPS redirect middleware redirects http requests to https. For example, http://labstack.com will be redirected to https://labstack.com.
Usage
e := echo.New() e.Pre(middleware.HTTPSRedirect()) HTTPS WWW Redirect HTTPS WWW redirect redirects http requests to www https. For example, http://labstack.com will be redirected to https://www.labstack.com.
Usage
e := echo.New() e.Pre(middleware.HTTPSWWWRedirect()) HTTPS NonWWW Redirect HTTPS NonWWW redirect redirects http requests to https non www. For example, http://www.labstack.com will be redirect to https://labstack.com.
Usage</description>
    </item>
    
    <item>
      <title>Request ID Middleware</title>
      <link>https://echo.labstack.com/middleware/request-id/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://echo.labstack.com/middleware/request-id/</guid>
      <description>Request ID middleware generates a unique id for a request.
Usage
e.Use(middleware.RequestID())
Custom Configuration Usage
e.Use(middleware.RequestIDWithConfig(middleware.RequestIDConfig{ Generator: func() string { return customGenerator() }, })) Configuration RequestIDConfig struct { // Skipper defines a function to skip middleware.  Skipper Skipper // Generator defines a function to generate an ID.  // Optional. Default value random.String(32).  Generator func() string } Default Configuration
DefaultRequestIDConfig = RequestIDConfig{ Skipper: DefaultSkipper, Generator: generator, } Set ID You can set the id from the requester with the X-Request-ID-Header</description>
    </item>
    
    <item>
      <title>Rewrite Middleware</title>
      <link>https://echo.labstack.com/middleware/rewrite/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://echo.labstack.com/middleware/rewrite/</guid>
      <description>Rewrite middleware allows to rewrite an URL path based on provided rules. It can be helpful for backward compatibility or just creating cleaner and more descriptive links.
Usage e.Pre(middleware.Rewrite(map[string]string{ &amp;#34;/old&amp;#34;: &amp;#34;/new&amp;#34;, &amp;#34;/api/*&amp;#34;: &amp;#34;/$1&amp;#34;, &amp;#34;/js/*&amp;#34;: &amp;#34;/public/javascripts/$1&amp;#34;, &amp;#34;/users/*/orders/*&amp;#34;: &amp;#34;/user/$1/order/$2&amp;#34;, })) The values captured in asterisk can be retrieved by index e.g. $1, $2 and so on. Each asterisk will be non-greedy (translated to a capture group (.*?)) and if using multiple asterisk a trailing * will match the &amp;ldquo;rest&amp;rdquo; of the path.</description>
    </item>
    
    <item>
      <title>Secure Middleware</title>
      <link>https://echo.labstack.com/middleware/secure/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://echo.labstack.com/middleware/secure/</guid>
      <description>Secure middleware provides protection against cross-site scripting (XSS) attack, content type sniffing, clickjacking, insecure connection and other code injection attacks.
Usage
e.Use(middleware.Secure())
Custom Configuration Usage
e := echo.New() e.Use(middleware.SecureWithConfig(middleware.SecureConfig{ XSSProtection: &amp;#34;&amp;#34;, ContentTypeNosniff: &amp;#34;&amp;#34;, XFrameOptions: &amp;#34;&amp;#34;, HSTSMaxAge: 3600, ContentSecurityPolicy: &amp;#34;default-src &amp;#39;self&amp;#39;&amp;#34;, })) Passing empty XSSProtection, ContentTypeNosniff, XFrameOptions or ContentSecurityPolicy disables that protection.
Configuration SecureConfig struct { // Skipper defines a function to skip middleware.  Skipper Skipper // XSSProtection provides protection against cross-site scripting attack (XSS)  // by setting the `X-XSS-Protection` header.</description>
    </item>
    
    <item>
      <title>Session Middleware</title>
      <link>https://echo.labstack.com/middleware/session/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://echo.labstack.com/middleware/session/</guid>
      <description>Session middleware facilitates HTTP session management backed by gorilla sessions. The default implementation provides cookie and filesystem based session store; however, you can take advantage of community maintained implementation for various backends.
 Echo community contribution
 Dependencies import ( &amp;#34;github.com/gorilla/sessions&amp;#34; &amp;#34;github.com/labstack/echo-contrib/session&amp;#34; ) Usage
e := echo.New() e.Use(session.Middleware(sessions.NewCookieStore([]byte(&amp;#34;secret&amp;#34;)))) e.GET(&amp;#34;/&amp;#34;, func(c echo.Context) error { sess, _ := session.Get(&amp;#34;session&amp;#34;, c) sess.Options = &amp;amp;sessions.Options{ Path: &amp;#34;/&amp;#34;, MaxAge: 86400 * 7, HttpOnly: true, } sess.</description>
    </item>
    
    <item>
      <title>Static Middleware</title>
      <link>https://echo.labstack.com/middleware/static/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://echo.labstack.com/middleware/static/</guid>
      <description>Static middleware can be used to serve static files from the provided root directory.
Usage
e := echo.New() e.Use(middleware.Static(&amp;#34;/static&amp;#34;)) This serves static files from static directory. For example, a request to /js/main.js will fetch and serve static/js/main.js file.
Custom Configuration Usage
e := echo.New() e.Use(middleware.StaticWithConfig(middleware.StaticConfig{ Root: &amp;#34;static&amp;#34;, Browse: true, })) This serves static files from static directory and enables directory browsing.
Default behavior when using with non root URL paths is to append the URL path to the filesystem path.</description>
    </item>
    
    <item>
      <title>Timeout Middleware</title>
      <link>https://echo.labstack.com/middleware/timeout/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://echo.labstack.com/middleware/timeout/</guid>
      <description>Timeout middleware is used to timeout at a long running operation within a predefined period.
Usage
e.Use(middleware.Timeout())
Custom Configuration Usage
e := echo.New() e.Use(middleware.TimeoutWithConfig(middleware.TimeoutConfig{ Skipper: Skipper, ErrorHandler: func(err error, e echo.Context) error { // you can handle your error here, the returning error will be  // passed down the middleware chain  return err }, Timeout: 30*time.Second, })) Configuration // TimeoutConfig defines the config for Timeout middleware. TimeoutConfig struct { // Skipper defines a function to skip middleware.</description>
    </item>
    
    <item>
      <title>Trailing Slash Middleware</title>
      <link>https://echo.labstack.com/middleware/trailing-slash/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://echo.labstack.com/middleware/trailing-slash/</guid>
      <description>Add Trailing Slash Add trailing slash middleware adds a trailing slash to the request URI.
Usage
e := echo.New() e.Pre(middleware.AddTrailingSlash()) Remove Trailing Slash Remove trailing slash middleware removes a trailing slash from the request URI.
Usage
e := echo.New() e.Pre(middleware.RemoveTrailingSlash()) Custom Configuration Usage
e := echo.New() e.Use(middleware.AddTrailingSlashWithConfig(middleware.TrailingSlashConfig{ RedirectCode: http.StatusMovedPermanently, })) Example above will add a trailing slash to the request URI and redirect with 301 - StatusMovedPermanently.
Configuration TrailingSlashConfig struct { // Skipper defines a function to skip middleware.</description>
    </item>
    
  </channel>
</rss>
